<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>F2 与 iconfont</title>
  <link rel="stylesheet" href="./assets/common.css">
  <link rel="stylesheet" href="./assets/fonts/iconfont.css">
  <style>
    canvas#mountNode {
      margin: 0 auto;
      display: block;
    }
  </style>
</head>
<body>
<div>
  <canvas id="mountNode"></canvas>
  <button id="changeData">更新数据</button>
</div>
<script src="./assets/jquery-3.2.1.min.js"></script>
<script src="../build/f2-all.js"></script>
<script>
    const data = [
      { amount: 16, ratio: 0.01, memo: '学习', namekey: 'namekey' },
      { amount: 16, ratio: 0.01, memo: '睡觉', namekey: 'namekey' },
      { amount: 16, ratio: 0.01, memo: '吃饭', namekey: 'namekey' },
      { amount: 2, ratio: 0.01, memo: '讲礼貌', namekey: 'namekey' },
      { amount: 4, ratio: 0.01, memo: '其他', namekey: 'namekey' },
      { amount: 81, ratio: 0.01, memo: '运动', namekey: 'namekey' },
      { amount: 20, ratio: 0.94, memo: '暂无备注', namekey: 'namekey' },
    ];
    const chart = new F2.Chart({
      id: 'mountNode',
      width: 300,
      height: 300,
      animate: false,
      pixelRatio: window.devicePixelRatio
    });

    chart.source(data);
    chart.coord('polar', {
      transposed: true,
      innerRadius: 0.4,
      radius: 0.5
    });
    chart.axis(false);
    chart.legend(false);
    chart.tooltip(false);
    chart.interval().position('namekey*ratio')
      .color('memo')
      .adjust('stack');
    chart.render();
    // >>>>>>>>>>>>>>>>>>>>>>>>> labeling <<<<<<<<<<<<<<<<<<<<<<<<<<

    const ANCHOR_OFFSET = 5; // 锚点的偏移量
    const OFFSET = 15; // 拐点的偏移量
    const APPEND_OFFSET = 10; // 文本距离画布四边的距离
    const LINEHEIGHT = 32; //
    const GAP = 15;

    const coord = chart.get('coord'); // 获取坐标系对象
    const center = coord.center; // 极坐标圆心坐标
    const r = coord.circleRadius; // 极坐标半径
    const canvas = chart.get('canvas');
    const canvasWidth = chart.get('width');
    const canvasHeight = chart.get('height');
    const labelGroup = canvas.addGroup();
    const labels = [];

    function getEndPoint(center, angle, r) {
      return {
        x: center.x + r * Math.cos(angle),
        y: center.y + r * Math.sin(angle)
      };
    }

    // 计算中间角度
    function getMiddleAngle(startAngle, endAngle) {
      if (endAngle < startAngle) {
        endAngle += Math.PI * 2;
      }
      return (endAngle + startAngle) / 2;
    }

    // 绘制文本以及连接线
    function drawLabel(label, isRight, maxLabelWidth) {
      const { _anchor, _router, fill, y, labelShape } = label;
      const lastPoint = {
        y
      };

      if (label._side === 'left') { // 具体文本的位置
        // 策略一：文本对齐边缘
        lastPoint.x = APPEND_OFFSET;
        labelShape.attr({
          textAlign: 'left',
          x: APPEND_OFFSET,
          y
        });
      } else {
        // 策略一：文本对齐边缘
        lastPoint.x = canvasWidth - APPEND_OFFSET;
        labelShape.attr({
          textAlign: 'right',
          x: canvasWidth - APPEND_OFFSET,
          y
        });
      }

      labels.push(labelShape);

      // 绘制锚点
      labelGroup.addShape('Circle', {
        attrs: {
          x: _anchor.x,
          y: _anchor.y,
          r: 2,
          fill
        }
      });
      // 绘制连接线
      let points;
      if (_router.y !== y) { // 文本位置做过调整
        // 策略一：文本对齐边缘
        if (_router.y < y) { // 文本被调整下去了
          let point1 = _router;
          let point2 =  {
            x: isRight === 0 ? lastPoint.x + maxLabelWidth + GAP : lastPoint.x - maxLabelWidth - GAP,
            y: _router.y
          };
          const point3 = {
            x: isRight === 0 ? lastPoint.x + maxLabelWidth : lastPoint.x - maxLabelWidth,
            y: lastPoint.y
          };

          points = [
            _anchor,
            point1,
            point2,
            point3,
            lastPoint
          ];

          if ((isRight === 1 && point2.x < point1.x) || (isRight === 0 && point2.x > point1.x)) {
            points = [
              _anchor,
              point3,
              lastPoint
            ];
          }
        } else {
          points = [
            _anchor,
            {
              x: _router.x,
              y
            },
            lastPoint
          ];
        }
      } else {
        points = [
          _anchor,
          _router,
          lastPoint
        ];
      }

      labelGroup.addShape('Polyline', {
        attrs: {
          points,
          lineWidth: 1,
          stroke: fill
        }
      });
    }

    function antiCollision(half, isRight) {
      const startY = center.y - r - OFFSET - LINEHEIGHT;
      let overlapping = true;
      let totalH = canvasHeight;
      let i;

      let maxY = 0;
      let minY = Number.MIN_VALUE;
      let maxLabelWidth = 0;
      const boxes = half.map(function(label) {
        const labelY = label.y;
        if (labelY > maxY) {
          maxY = labelY;
        }
        if (labelY < minY) {
          minY = labelY;
        }

        const labelShape = label.labelShape;
        const labelWidth = labelShape.getBBox().width;
        if (labelWidth >= maxLabelWidth) {
          maxLabelWidth = labelWidth;
        }

        return {
          size: LINEHEIGHT,
          targets: [labelY - startY]
        };
      });
      if ((maxY - startY) > totalH) {
        totalH = maxY - startY;
      }

      while (overlapping) {
        boxes.forEach(box => {
          const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
          box.pos = Math.min(Math.max(minY, target - box.size / 2), totalH - box.size);
        });

        // detect overlapping and join boxes
        overlapping = false;
        i = boxes.length;
        while (i--) {
          if (i > 0) {
            const previousBox = boxes[i - 1];
            const box = boxes[i];
            if (previousBox.pos + previousBox.size > box.pos) { // overlapping
              previousBox.size += box.size;
              previousBox.targets = previousBox.targets.concat(box.targets);

              // overflow, shift up
              if (previousBox.pos + previousBox.size > totalH) {
                previousBox.pos = totalH - previousBox.size;
              }
              boxes.splice(i, 1); // removing box
              overlapping = true;
            }
          }
        }
      }

      // step 4: normalize y and adjust x
      i = 0;
      boxes.forEach(function (b) {
        let posInCompositeBox = startY; // middle of the label
        b.targets.forEach(function () {
          half[i].y = b.pos + posInCompositeBox + LINEHEIGHT / 2;
          posInCompositeBox += LINEHEIGHT;
          i++;
        });
      });

      half.forEach(function (label) {
        drawLabel(label, isRight, maxLabelWidth);
      });
    }

    function addPieLabel(chart) {
      const halves = [
        [], // left
        [] // right
      ]; // 存储左右 labels
      labelGroup && labelGroup.clear();
      const geom = chart.get('geoms')[0];
      // 获取文本的信息
      const shapes = geom.get('container').get('children');
      shapes.forEach(shape => {
        const shapeAttrs = shape.attr();
        const origin = shape.get('origin');
        const { startAngle, endAngle } = shapeAttrs;
        const middleAngle = getMiddleAngle(startAngle, endAngle);
        const edgePoint = getEndPoint(center, middleAngle, r + ANCHOR_OFFSET);
        const routerPoint = getEndPoint(center, middleAngle, r + OFFSET);
        const label = {
          _anchor: edgePoint,
          _router: routerPoint,
          _data: origin._origin,
          x: routerPoint.x,
          y: routerPoint.y,
          r: r + OFFSET,
          fill: origin.color // 字体颜色
        };

        const labelAttrs = {
          x: 0,
          y: 0,
          fontSize: 12, // 字体大小
          fill: '#808080',
          // text: label._data.memo,
          text: label._data.year + '\n' + label._data.population,
          textBaseline: 'middle'
        };
        const labelShape = labelGroup.addShape('Text', {
          attrs: labelAttrs
        });
        label.labelShape = labelShape;
        // 判断文本的方向
        if (edgePoint.x < center.x) {
          label._side = 'left';
          halves[0].push(label);
        } else {
          label._side = 'right';
          halves[1].push(label);
        }
      });

      const maxCountForOneSide = parseInt(canvasHeight / LINEHEIGHT, 10);

      halves.forEach((half, index) => {
        // step 2: reduce labels
        if (half.length > maxCountForOneSide) {
          half.sort((a, b) => {
            return b._percent - a._percent;
          });
          half.splice(maxCountForOneSide, half.length - maxCountForOneSide);
        }

        // step 3: distribute position (x and y)
        half.sort((a, b) => {
          return a.y - b.y;
        });

        antiCollision(half, index);
        canvas.draw();
      });
    }

    addPieLabel(chart);
    // ================= 改变数据 ========================
      function randomData(data) {
        data.map(obj => {
          obj.ratio = Math.random();
          return obj;
        });
        return data;
      }

      $('#changeData').on('click', () => {
        const newData = randomData(data);
        console.log(JSON.stringify(newData));
        chart.changeData(newData);
        setTimeout(function () {
          addPieLabel(chart);
        }, 350); // 必须在更新动画结束之后再绘制，默认的更新时间是 300
      });
</script>
</body>
</html>
